"""
Reads JSON files describing Redis commands (one top-level key per file),
and generates C++23 classes implementing ICommand.

Usage:
    python generate_commands.py --input commands/ --output out/

Requirements: Python 3.8+
No external packages required.
"""
import argparse
import json
from pathlib import Path
import re
from typing import Dict, Any, List, Optional

# ---------------------------
# Utilities: naming, type map
# ---------------------------
def camel_case_from_tokens(tokens: List[str]) -> str:
    return "".join(t.capitalize() for t in tokens if t)

def sanitize_token(tok: str) -> str:
    # Keep alphanumeric only
    return re.sub(r'[^0-9A-Za-z]+', ' ', tok).strip()

def class_name_for_command(key: str, container: Optional[str]) -> str:
    # e.g. key="INFO", container="CLUSTER" -> ClusterInfoCommand
    parts = []
    if container:
        parts.extend(sanitize_token(container).split())
    parts.extend(sanitize_token(key).split())
    return camel_case_from_tokens([p.lower() for p in parts]) + "Command"

# Map JSON arg types to C++ types
def cpp_type_for_argument(arg: Dict[str, Any]) -> str:
    t = arg.get("type")
    # handle block/oneof as opaque for now -> string or vector depending on multiple
    base = "std::string"
    if t == "double":
        base = "double"
    elif t == "integer":
        base = "long long"
    elif t == "key":
        base = "std::string"
    elif t == "pattern":
        base = "std::string"
    elif t == "string":
        base = "std::string"
    elif t == "unix-time":
        base = "long long"
    elif t == "pure-token":
        base = "std::string"
    elif t == "block" or t == "oneof":
        # complicated nested structures; treat as string placeholder
        base = "std::string"
    else:
        base = "std::string"

    if arg.get("multiple"):
        return f"std::vector<{base}>"
    if arg.get("optional"):
        return f"std::optional<{base}>"
    return base

def cpp_member_name(arg_name: str) -> str:
    # convert name like "message" or "some-arg" to member variable name
    s = sanitize_token(arg_name).replace(" ", "_").lower()
    return s

# ---------------------------
# Template pieces
# ---------------------------
ICOMMAND_HPP = """#pragma once
#include <memory>

class ICommand {
public:
  virtual void serveRequest() = 0;
  virtual ~ICommand() = default;
};
"""

DATABASE_HPP = """#pragma once
#include <string>

// Minimal placeholder Database interface expected by generated commands.
// Replace/expand with your real database API.
class Database {
public:
    virtual ~Database() = default;

    // Example placeholders:
    virtual std::string get(const std::string &key) = 0;
    virtual void set(const std::string &key, const std::string &value) = 0;
};
"""

HEADER_TEMPLATE = """#pragma once
// Generated by json2cpp_commands.py — C++23
#include <memory>
#include <string>
#include <vector>
#include <optional>

#include "command.hpp"
#include "database.hpp"
#include "bulk_string.hpp" // assume BulkString exists

{extra_includes}

class {class_name} : public ICommand {{
public:
    explicit {class_name}(std::shared_ptr<Database> db, int client_fd) noexcept;
    ~{class_name}() override = default;

    // No copy, allow move
    {class_name}(const {class_name}&) = delete;
    {class_name} &operator=(const {class_name}&) = delete;
    {class_name}({class_name}&&) noexcept = default;
    {class_name} &operator=({class_name}&&) noexcept = default;

    // Implements ICommand
    void serveRequest() override;

{member_decls}

private:
    std::shared_ptr<Database> db_;
    int client_fd;
}};
"""

CPP_TEMPLATE = """// Generated by json2cpp_commands.py — C++23
#include "{header_file}"
#include <iostream>

// Implementation for {class_name}

{class_name}::{class_name}(std::shared_ptr<Database> db, int client_fd) noexcept
    : db_(std::move(db)), client_fd(client_fd)
{{
}}

// serveRequest skeleton
void {class_name}::serveRequest() {{

    std::cout << "[serveRequest] {class_name} called\\n";
}}
"""

# ---------------------------
# Generator core
# ---------------------------
def generate_for_json(command_key: str, body: Dict[str, Any], out_dir: Path, filename_stem: str):
    container = body.get("container")
    class_name = class_name_for_command(command_key, container)
    header_file = out_dir / f"{class_name}.hpp"
    cpp_file = out_dir / f"{class_name}.cc"

    # members from arguments
    args = body.get("arguments", [])
    member_lines = []
    for arg in args:
        name = arg.get("name", "arg")
        mname = cpp_member_name(name)
        ctype = cpp_type_for_argument(arg)
        member_lines.append(f"    {ctype} {mname}_{{}};  // {arg.get('type')}")
    member_decls = "\n".join(member_lines) if member_lines else "    // No structured arguments parsed yet."

    # additional includes if needed
    extra_includes = ""
    # add <chrono> if unix-time used
    if any(a.get("type") == "unix-time" for a in args):
        extra_includes = "#include <chrono>"

    # reply_schema comment
    reply_schema = body.get("reply_schema")
    if reply_schema:
        reply_comment = "    // Reply schema (from JSON):\n"
        pretty = json.dumps(reply_schema, indent=4)
        for line in pretty.splitlines():
            reply_comment += f"    // {line}\n"
    else:
        reply_comment = "    // No reply_schema in JSON."

    header_src = HEADER_TEMPLATE.format(
        extra_includes=extra_includes,
        class_name=class_name,
        member_decls=member_decls
    )

    cpp_src = CPP_TEMPLATE.format(
        header_file=f"{class_name}.hpp",
        class_name=class_name,
        reply_schema_comment=reply_comment
    )

    header_file.write_text(header_src)
    cpp_file.write_text(cpp_src)

    print(f"Generated: {header_file}  and  {cpp_file}")

def main():
    parser = argparse.ArgumentParser(description="JSON -> C++ command class generator")
    parser.add_argument("--input", "-i", type=Path, required=True, help="Input directory with JSON files")
    parser.add_argument("--output", "-o", type=Path, required=True, help="Output directory for generated C++ files")
    args = parser.parse_args()

    input_dir: Path = args.input
    output_dir: Path = args.output
    output_dir.mkdir(parents=True, exist_ok=True)

    # iterate JSON files
    for path in sorted(input_dir.glob("*.json")):
        try:
            j = json.loads(path.read_text())
        except Exception as e:
            print(f"Skipping {path}: failed to parse JSON: {e}")
            continue

        # Expect a single top-level key
        if not isinstance(j, dict) or len(j.keys()) != 1:
            print(f"Skipping {path}: expected a single top-level key")
            continue
        command_key = next(iter(j.keys()))
        body = j[command_key]
        if not isinstance(body, dict):
            print(f"Skipping {path}: value for {command_key} is not an object")
            continue

        # pass along filename stem for disambiguation if needed
        filename_stem = path.stem
        generate_for_json(command_key, body, output_dir, filename_stem)

if __name__ == "__main__":
    main()

